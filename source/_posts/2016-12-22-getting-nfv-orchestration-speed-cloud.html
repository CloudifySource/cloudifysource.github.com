---
layout: blogpost
title: Getting NFV Orchestration Up to Speed with the Cloud
description: Tom Nolle explains why NFV Modeling is all about the right approach, not just the tool.
image: tomnolle.jpg
author: Tom Nolle, CIMI Corporation - Guest Post
tags: 
 - NFV
 - TOSCA
 - VNF Management
 - VNF
 - NFV Orchestration
---

<notextile>

<img src="/img/blog/nfv_service_modeling.png" alt="Network serivce model with Cloudify, TOSCA, and YANG" width="870">
<br/>
<br/>

<p><b><em>This post was originally published on December 15, 2016 on the <a href="http://blog.cimicorp.com/?p=2900" target="_blank">CIMI Corp blog</a> and was posted with the permission of the author. NOTE: This post is not an endorsement by the author of Cloudify or any other NFV vendor tool or solution.</em></b></p>

<p>Whatever else you have, or think you have, the NFV business case will depend on software automation of the service lifecycle.&nbsp; VNFs matter functionally, but only if you can operationalize them efficiently and only if they combine to drive carrier-cloud adoption.&nbsp; The core of any justification for <a href="http://getcloudify.org/network-function-virtualization-vnf-nfv-orchestration-sdn-platform.html" target="_blank">NFV deployment</a> in the near term is operational efficiency.&nbsp; Software automation generates that, if you have it at all.&nbsp; The core for the future is service agility and low cost, and software automation generates that too.&nbsp; Get it right, and you&rsquo;re everywhere.&nbsp; Get it wrong and you&rsquo;re nowhere.</p>
<p>Getting software automation right is largely a matter of modeling, but not &ldquo;modeling&rdquo; in the sense of somehow picking an optimum modeling language or tool.&nbsp; You can actually do a good job of <a href="http://getcloudify.org/2015/01/07/VNF-network-function-virtualization-netconf-yang-NFV.html" target="_blank">NFV service modeling</a> with nothing more than XML.&nbsp; What you can&rsquo;t do without is the right <strong>approach</strong>, meaning you can&rsquo;t do without knowing what you&rsquo;re modeling in the first place.&nbsp; You are not modeling network topology, or even service topology.&nbsp; You&rsquo;re modeling <strong>multi-domain deployment</strong>.</p>

<hr>

<span class="pullquote-left">
  <font style="font-weight: bold" size="5" face="Baskerville Old Face"><em>Get the White Paper - Making Your Virtual Appliance a Cloud Native VNF.</em></font>&nbsp; <a class="btn btn-medium btn-theme btn-rounded" id="downloadBtnInner" href="http://getcloudify.org/from-virtual-appliance-to-cloud-native-vnf-whitepaper.html" target="_blank"><i class="icon-plus"></i> Go </a></span>
  
<hr>


<p>A service, from the top, is a retail contract with an SLA.&nbsp; You can express this as an intent model that defines first the service points (ports) where users connect and then as the characteristics the service presents at those points, which is the SLA.&nbsp; In the most general case, therefore, the high-level service looks like a list of port-classes representing one or more types of user connection, and a list of ports within each class.&nbsp; It also represents a list of service-classes available at these ports, again as SLAs.</p>
<p>Most people agree with this at this high level.&nbsp; The problem comes when you try to go downward, to deploy this on resources.&nbsp; There we have a whole series of approaches that essentially come down to two&mdash;the <strong>model decomposition</strong> approach and the <strong>model deployment</strong> approach.</p>
<p>Model deployment is what a lot of vendors have thought of.&nbsp; In model deployment, a service model is linked to a series of scripts that provision resources, manipulate management interfaces, invoke controllers, and so forth.&nbsp; Even if model-deployment implementations of NFV allow for the &ldquo;nesting&rdquo; of models to, for example, split an IP VPN service into the VPN Core and Access components, the bulk of the provisioning decisions are made in one giant step.</p>
<p>Model decomposition is different.&nbsp; Here the goal is to define a service from top to bottom in abstract.&nbsp; A Service consists of a Core element and Access.&nbsp; Each of these can then be divided&mdash;Access into point-of-attachment features (firewall, etc.) and access connectivity.&nbsp; Those can then be divided into specifics&mdash;the specific edge features, the specific connectivity type.&nbsp; You go as far as you can go in decomposition of a service before you start thinking about implementation.</p>
<p>The easiest way to assess these differences is to look at the two logical ends of a service deployment, the service-level and the resource management.&nbsp; What the two approaches do at these extremes will likely determine how broadly useful, or risky, they could be.&nbsp; That&rsquo;s particularly true when you assume that networks are already populated with different technologies, and multiple vendors within each.&nbsp; We&rsquo;re now introducing SDN and NFV, and they won&rsquo;t deploy uniformly or instantly.&nbsp; The network we&rsquo;re trying to software-control is in a state of confusion and flux technically.</p>
<p>In the model-deployment approach, the process of building an access connection across multiple technology and vendor choices has to be built into the logic of the model that represents the VPN.&nbsp; If we imagine this as a script, the script has to account for any variation in the way something gets deployed because of the technology available there, the vendor and API standards, etc.&nbsp; As a result, there is a risk that you might end up with many, many, versions of &ldquo;IP VPN&rdquo;, with each version differing in what technology mix it&rsquo;s designed to deploy on.&nbsp; Changes in the network because of orderly evolution would break the scripts that depended on the old configuration, and if you wanted to change a service based on a customer order, the change might be radical enough to force you to break down one deployment model and initiate another.&nbsp; Even a failure, one that for example shifts a piece of a service from a VNF to a legacy device, might not be handled except by kill-and-start-over.</p>
<p>At the other end of the service, the top end, having a lot of implementation details puts pressure on the service order and management portals, because if you make the wrong selection of a model element to represent the order, the order might not even be compatible with your choice.&nbsp; You also have to resolve the management portal relationship with all the resource details, and if every model deploys differently on different equipment, the harmonization of the management view would have to be explicitly part of the deployment process, and it would be as brittle as the models were.&nbsp; You could change how a service was deployed and it would then change what the user saw on a management console, or could do in response to what they saw.</p>
<p>You probably think that the model-decomposition approach solves all of this, but that&rsquo;s not totally true.&nbsp; Model decomposition would typically be based on the notion of &ldquo;successive abstractions&rdquo;.&nbsp; A &ldquo;service&rdquo; would decompose into &ldquo;sub-services&rdquo; like Access and VPN Core.&nbsp; Each of the sub-services would decompose into &ldquo;feature elements&rdquo;, and each feature element into a &ldquo;virtual device&rdquo; set.&nbsp; Virtual devices could even decompose into &ldquo;device-class variants&rdquo; before you actually started putting service pieces onto network or hosting resources.&nbsp; This structure, in and of itself, can contain the impact of changes in infrastructure or service, and it can also make it easier to substitute one &ldquo;tree&rdquo; of decomposition (targeting, for example, real Cisco routers) with another (targeting virtual router instances hosed as VNFs).&nbsp; It doesn&rsquo;t necessarily make things dynamic, and it doesn&rsquo;t solve the management problem.</p>
<p>What you really need to have to do both these things is an extension of the basic notion of model-decomposition, which is this:&nbsp; <strong>since every model element is an intent model known to the outside world only by its properties, which include its SLA, you can manage every model element, and should</strong>.&nbsp; If you have an element called &ldquo;Access&rdquo;, it has an SLA.&nbsp; Its sub-elements, whether they are divided by administrative domain, geography, or technology, also have SLAs.&nbsp; The SLA of any &ldquo;superior&rdquo; object drives the SLAs of the subordinate objects, which at the bottom then drive the network behavior you&rsquo;re parameterizing, configuring, and deploying.&nbsp; You can provide a user or customer service rep with SLA status at any intent model, and they see the SLA there, which is what they&rsquo;d expect.&nbsp; Only at the bottom do you have a complicated task of building an SLA from deployed behaviors.</p>
<p>Speaking of the bottom, it&rsquo;s helpful here to think about a companion activity to the service modeling we&rsquo;ve been talking about.&nbsp; Suppose that every administrative domain, meaning area where common management span of control exists, has its own &ldquo;services&rdquo;, presented at the bottom and utilized in combination to create the lowest-level elements inside the service models?&nbsp; In my ExperiaSphere project I called these resource-side offerings <strong>Behaviors</strong> to distinguish them from retail elements.&nbsp; They&rsquo;d roughly correspond to the resource-facing services (RFS) of the TMF, and so my &ldquo;service models&rdquo; would roughly map to the TMF customer-facing services (CFS).</p>
<p>Now we have an interesting notion to consider.&nbsp; Suppose that every metro area (as an administrative domain) advertises the same set of behaviors, regardless of their technology mix and the state of their SDN/NFV evolution?&nbsp; You could now build service models referencing these behaviors that, when decomposed by geography to serve the specified endpoints, would bind to the proper behaviors in each of the metro areas.&nbsp; Service composition now looks the same no matter where the customers are.</p>
<p>I&rsquo;ve described this as a <strong>service-domain/resource-domain</strong> split, and in my own model the split occurs where technical capabilities are linked to functional requirements&mdash;&ldquo;Behaviors&rdquo; are linked to &ldquo;service elements&rdquo;.&nbsp; Above the split, the model is primarily functional and logical, though in all cases a model element that has for example five underlayment elements to integrate would have to control the gateway processes that connect them.&nbsp; Below the split, the goal is primarily technical.&nbsp; You could justify a difference in modeling approach above and below, and even multiple modeling strategies in the resource domain, as long as the same behavior set was presented in the same way to the service domain.</p>
<p>This approach, which combines service-modeling using intent-based abstractions with resource modeling that takes place underneath a single set of &ldquo;behaviors&rdquo; abstractions that are presented upward, seems to me to offer the right framework for software automation of the service lifecycle processes.&nbsp; Each of the model abstractions is a state/event machine whose states are self-determined by the architect who builds them, and whose events are generated by the objects immediately above or within.&nbsp; The states and events create, for each model element we have, a table of processes to be used to handle the event in each possible operating state.&nbsp; That&rsquo;s how service lifecycle management has to work.</p>
<p>I like <a href="http://getcloudify.org/2016/10/13/hybrid-cloud-orchestration-on-openstack-with-cloudify-tosca.html" target="_blank">TOSCA</a> as a modeling approach for this, but as I said what&rsquo;s critically important is that the modeling technology support the structure I&rsquo;m describing.&nbsp; It&rsquo;s a major plus if there are tools to manage the models available in the open-source community.&nbsp; TOSCA is already gaining acceptance as part of vendor NFV strategies.&nbsp; It&rsquo;s supported by <a href="http://getcloudify.org" target="_blank">Cloudify</a> as a specific NFV solution (through <a href="http://ariatosca.org" target="_blank">Aria</a>, a general modeling tool), Alien4Cloud, and Ubicity.&nbsp; OpenStack&rsquo;s HEAT is based on it, and so is Amazon&rsquo;s CloudFormation.&nbsp; OpenTOSCA, an open-source implementation of the model, was used by Jorge Cardoso in a proof-of-concept university project I&rsquo;ve often cited.&nbsp; There are also some NFV ISG TOSCA documents available.&nbsp; I think TOSCA is the smart choice in the service domain, and also at the top of the resource domain.</p>
<p>What happens in that resource area, below where TOSCA is a good choice?&nbsp; That&rsquo;s by definition inside an opaque intent model, so in truth it doesn&rsquo;t matter.&nbsp; Any administrative domain could use any modeling and deployment tools they liked as long as they were published as something like my Behaviors to be used in services.&nbsp; TOSCA would work there overall, and work best IMHO where cloud elements (like VNFs) deploy, but the key to NFV success is to embrace whatever equipment is out there, and demanding a reformulation of the management of that equipment to support a new model wouldn&rsquo;t make sense.</p>
<p>I think that this software automation approach handles <a href="http://getcloudify.org/cloud_orchestration_cloud_automation.html" target="_blank">orchestration and full lifecycle management</a>, can easily support wholesale/retail partners, 5G slicing and operating within those slices as a VNO, and any combination of legacy vendors and technologies, as well as SDN and NFV.&nbsp; There may be other ways too, and I&rsquo;m not trying to say this is the only solution. It is, however, a good solution and one I&rsquo;m absolutely confident could work as well as any in making SDN and NFV transformation successful.&nbsp; It&rsquo;s fully described in my ExperiaSphere material (<a href="http://www.experiasphere.com/page16.html">http://www.experiasphere.com/page16.html</a>) and please note that I&rsquo;ve made all this available and open without restrictions, even attribution, as long as you don&rsquo;t use the trademarked name.&nbsp; Take a look and see if it works for you, and let me know if you find something better.</p>


</notextile>